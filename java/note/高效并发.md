# java内存模型和线程
## 硬件的效率与一致性
让计算机并发执行若干个运算任务与更充分地利用计算机处理器的效能之间的因果关系，实际上它们之间并没有想象种那么简单，其中一个重要的复杂性就是绝大多数的运算任务都不可能只靠处理器计算就可以完成，处理器至少要和内存交互。由于计算机的存储设备和处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据拷贝到缓存种，让运算能够快速进行，当运算结束后将数据从缓存同步到内存中，这种就是典型的缓存模型

基于高速缓存的存储交互很好地解决了处理器和内存速度之间地矛盾，但是也引入了一个问题：缓存一致性。在多路处理器系统中，每一个处理器都有自己的高速缓存，而它们又共享同一个主内存，这种系统称为共享内存多核系统，也就是当多个处理器都访问同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决缓存一致性问题，需要各个处理器访问缓存时遵循一些协议，在读写时根据协议来读写，这类协议有MSI、MESI、MOSI等
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22646069/1664689337276-0cc661a1-2f88-4a5c-a74a-8e0a486284e3.png#averageHue=%23f6f6f6&clientId=u06cca089-b701-4&from=paste&height=338&id=u36621be9&originHeight=422&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110099&status=done&style=none&taskId=u572b463d-fbb7-4d5f-9d6b-1ce0ee2170f&title=&width=720)

# java内存模型
## 主内存和工作内存
java内存模型的主要目的就是定义程序各种变量的访问规则，即关注在虚拟机中将变量值存储到内存和从内存中取出变量值这样的底层细节，此处的变量与java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包含局部变量与方法参数，因为后者是线程私有的，不会被共享，自然不会有竞争问题

java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存（类似处理高速缓存），线程的工作内存中保存了该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的副本
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22646069/1664689893070-98ab6253-4da8-4f4b-a847-a45470050108.png#averageHue=%23f6f6f6&clientId=ueb11e535-18c0-4&from=paste&height=326&id=u2ad5ee10&originHeight=408&originWidth=843&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106364&status=done&style=none&taskId=udc28cefe-2f03-4845-a81d-7ad8c0cbcb0&title=&width=674.4)
> 这里所谓的主内存、工作内存和之前的java的堆、栈、方法区并不是一个层次的对内存的划分，这两者基本没有什么关系。如果一定要对应起来，那么主内存主要对应于java堆中的对象实例数据部分，而工作内存对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行主要访问你的工作内存


## 内存间的交互操作
java内存模型中定义了八种操作来完成将一个变量从主内存拷贝到工作内存，从工作内存同步回主内存这一类操作，虚拟机实现时需要保证下面这些操作是原子性的：

- lock锁定：作用于主内存的变量，它将一个变量标识为一条线程独占的状态
- unlock解锁：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定
- read读取：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load载入：作用于工作内存的变量，它将read操作从主内存中得到的变量值放入工作内存的变量副本中
- use使用：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行操作
- assign赋值：作用于工作内存的变量，它将一个从执行引擎接收的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时就会执行这个操作
- store存储：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
- write写入：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

如果要将一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按照顺序执行store和write操作。java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行，也就是read和load之间、store和write之间是可以插入其他指令的，java内存模型还规定了在执行八种基本操作时必须满足以下规则：

- 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现 
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
- 不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或 assign）的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作
- 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 
- 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。
- 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量
- 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）

## 对于volatile型变量的特殊规则
关键字volatile是java虚拟机中提供的最轻量级的同步机制，当一个变量被定义成volatile之后，它将具备两种特性：

- 保证此变量对所有线程的可见性，可见性是指当一条线程修改了这个变量的值之后新的值对于其他线程来说是可以立即得知的，而普通变量的值在线程间的传递均需要通过主内存来完成
- 禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序于代码中的顺序一致
> volatile关键字并不能保证运算的并发安全，类似于多线程操作一个变量自增的情况还是需要用synchronized关键字进行加锁

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22646069/1664692658309-262f317b-1ddb-4e17-ad4f-bae7fae91114.png#averageHue=%23fefdfc&clientId=ueb11e535-18c0-4&from=paste&height=629&id=ud6702df7&originHeight=786&originWidth=652&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71095&status=done&style=none&taskId=ud90cc5c7-822f-4c8e-855b-b15ffaa15b6&title=&width=521.6)


> 指令重排序是指机器级的优化操作，是并发编程中最容易导致疑惑的地方之一，典型的例子就是双锁检测单例代码，如果对于单例变量不加上volatile关键字的话可能出现线程引用了空指针

![image.png](https://cdn.nlark.com/yuque/0/2022/png/22646069/1664692836446-62630854-21fa-4b0f-96b0-f17768198da8.png#averageHue=%23f9f8f8&clientId=ueb11e535-18c0-4&from=paste&height=414&id=u207d904b&originHeight=517&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49093&status=done&style=none&taskId=u63fad38c-7be5-4f6d-b4ac-f5bade7bf2d&title=&width=577.6)
在加上volatile关键字之后，赋值操作后多执行了一个lock addl$0x0,(%esp)操作，这个操作的作用相当于一个内存屏障（指重排序的时候不能把后面的指令重排序到内存屏障之前的位置），只有一个处理器访问内存的时候，并不需要内存屏障，但是如果有两个或者多个处理器一起访问同一块内存，并且其中一个在观测另一个时就需要内存屏障来保证一致性
![image.png](https://cdn.nlark.com/yuque/0/2022/png/22646069/1664693196140-11493e34-6c20-4fc5-9c27-3c8e301752fb.png#averageHue=%23f6f5f3&clientId=ueb11e535-18c0-4&from=paste&height=238&id=ufd35971c&originHeight=297&originWidth=897&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55389&status=done&style=none&taskId=u954c43bc-e160-46bd-951a-e7353a786e7&title=&width=717.6)

以上指令中的add$0x0,(%esp)（将ESP寄存器的值加上0）这显然是一个空操作，之所以用这个空操作而不是使用专用指令nop，是因为IA32手册规定lock前缀不允许配合nop指令使用，这里关键在于lock，它的作用是将本处理器的缓存写入内存，该写入动作会引起别的处理器或者别的内存无效化其缓存，这种操作相当于对缓存中的变量做了一次前面的store和write操作，然后让volatile变量的修改对其他处理器立即可见

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，来保证原子性：

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程在修改
- 变量不需要与其他的状态变量共同参与不变约束


## 针对long和double变量的特殊规则
java内存模型要求lock、unlock、read、load、assign、use、store、write这八种操作都具有原子性，但是对于64位的数据类型，在模型中特别定义了一条宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现自行选择是否要保证64位数据类型的load、store、read和write这四个操作的原子性，这就是所谓的long和double的非原子性协定

如果有多个线程共享一个并未声明volatile的long或者double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程读取到一个既不是原值也不是其他线程修改的代表了半个变量的值，不过这种现象非常罕见

# 原子性、可见性和有序性
## 原子性
由java内存模型来直接保证的原子性变量操作包含read、load、assign、use、store和write这六个，我们大致可以认为基本数据类型的访问和读取都是具备原子性。如果应用场景需要一个更大范围的保证，java内存模型中提供了lock和unlock来满足这种需求，体现到代码上就是synchronized关键字

## 可见性
可见性就是当一个线程修改了共享变量时，其他线程能够立即知道这个修改。java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是volatile变量都是这样。但是普通变量和volatile变量的区别是volatile的特殊规则保证了新值能够立即同步到主内存，以及每次使用前立即从主内存刷新，因此我们可以说volatile保证了变量可见性

除了volatile关键字外，java另外两个关键字：synchronized和final也可以保证可见性，前者的可见性保证是指对一个变量执行unlock操作之前，必须先将此变量同步回主内存中这条规则的约束，后者的可见性是指被final修饰的变量的字段在构造器中一旦被初始化完成，并且构造器没有将this传递出去（this引用逃逸是一件危险的事情，其他线程有可能拿到初始化一半的对象），那么其他线程中就能看到final字段的值

## 有序性
java内存模型的有序性就是如果在本线程内观察，所有操作都是有序的，如果在一个线程中观察另外一个线程，所有的操作都是无序的，前半句是指线程内似表现为串行的语义，后半句是指指令重排序现象和工作内存与主内存同步延迟现象

java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的含义，而synchronized则是由一个变量在同一个时刻只允许一条线程对其进行lock操作这条规则获得的

